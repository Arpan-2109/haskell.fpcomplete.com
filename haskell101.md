# Haskell 101

Quick review of Haskell, and try to solidify naming we'll use for this
course.

## Data types

* Type synonyms: `type String = [Char]`
* Newtypes: `newtype Age = Age Int` or `newtype Age = Age { unAge :: Int }`
* Data declaration
    * Product type: `data Person = Person Name Age`
    * Product w/record: `data Person = Person { personName :: Name, personAge :: Age }`
    * Enum: `data Fruit = Apple | Banana | Pear`
    * Mix them (proper sums): `data Age = UnknownAge | KnownAge Int`

Terms:

* `Fruit` is a _type constructor_
* `Fruit` is also a _type_
* `Apple`, `Banana`, and `Pear` are _data constructors_
* `Person` is both a type and data constructor
    * They live in separate namespaces, that's fine

Type variables:

* `data Maybe a = Nothing | Just a`
* `a` is a type variable
* `Maybe` is a type constructor
* However, `Maybe` is _not_ a type!
* `Maybe` has kind `Type -> Type`, aka `* -> *`
* `Maybe Int` is a type

More on data types in next section.

## Syntactic sugar everywhere

Function calls:

```haskell
foo x y = ...
foo = \x y -> ...
foo = \x -> \y -> ...
```

All the same, allow for partial function application (not the same as
partial functions!).

Pattern matching:

```haskell
fromMaybe def Nothing = def
fromMaybe _def (Just x) = x

fromMaybe def mx =
  case mx of
    Nothing -> def
    Just x -> x

{-# LANGUAGE LambdaCase #-}
fromMaybe def = \case
  Nothing -> def
  Just x -> x
```

Also:

```haskell
if x then y else z

case x of
  True -> y
  False -> z
```

## Partial/total functions

__Bottom value__: when evaluated, throws a runtime exception or loops
infinitely

```haskell
bottom1 = error "I'm bottom!"
bottom2 = undefined
bottom3 = _ -- probably fails at compile time
bottom4 = let x = x in x -- infinite loop, runtime may detect it
```

__Total function__ produces a non-bottom output for all non-bottom
input.

__Partial function__ may produce a bottom output for some non-bottom
input.

Partiality can sneak in:

* Partial pattern matches
* Lambdas on sum types
* Infinite loops
* Turn on `-Wall`!

## Language extensions

50% of all production Haskell code is language extension and import
lines

```haskell
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE GADTs #-}
```

Added at the top of your file. Basic structure:

```haskell
#!/usr/bin/env stack
-- stack --resolver lts-11.10 script
-- Above two lines for scripts, we'll cover that below
{-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE ... #-}
{-# OPTIONS_GHC -Wall #-} -- better in package.yaml file, below
module Main (main) where

import Control.Monad (when)
-- import ...

main :: IO ()
main = putStrLn "Finally, some actual code!"
```

See: https://github.com/commercialhaskell/rio#language-extensions

## Alternative preludes

Default prelude kinda sucks:

* Bad data structures
* Missing common functionality
* Partial functions everywhere
* Lots of people use alternative preludes

I'll lean on the `rio` project in this training. We can discuss later
various trade-offs.

## Tooling overview

* __GHC__ Compiler
    * GHCJS, JHC, others...
    * Almost everyone uses GHC
* __Stack__ build tool
    * Downloads GHC for you
    * Installs packages
* __Emacs__ editor
    * intero-mode works pretty well
    * And many others
* __hlint__ linter, __hoogle__ search

### Cabal packages

* Have a name and version number
* 0-1 libraries
* 0 or more executables
* 0 or more test suites
* 0 or more benchmarks
* Configured via `projectname.cabal`
* Or if you're cool: `package.yaml` and `hpack`
* Can be released as open source to Hackage

### hpack example

Source file (`app/Main.hs`):

```haskell
import Acme.Missiles

main :: IO ()
main = launchMissiles
```

hpack config file (`package.yaml`):

```yaml
name:                hello-hpack
version:             0.1.0.0

dependencies:
- base

executables:
  hello-hpack:
    dependencies:     acme-missiles
    source-dirs:      app
    main:             Main.hs
```

The `hello-hpack.cabal` file is automatically generated by Stack.

```cabal
-- This file has been generated from package.yaml by hpack version 0.17.0.
--
-- see: https://github.com/sol/hpack

name:           hello-hpack
version:        0.1.0.0
build-type:     Simple
cabal-version:  >= 1.10

executable hello-hpack
  main-is: Main.hs
  hs-source-dirs:
      app
  build-depends:
      base
    , acme-missiles
  default-language: Haskell2010
```

### Stackage snapshot

* Specifies a specific GHC version
* Specifies a collection of Cabal packages from Hackage
* Specifies build flags
* Nightly: one per day, try to take the latest version from Hackage
* LTS (Long Term Support): weekly, tries to maintain backwards
  compatibility based on PVP
* Guarantee: we got these packages to compile together and pass tests

### Stack projects

* Configured via `stack.yaml` file
* 0 or more local Cabal packages
* Specifies a *resolver*
    * Stackage snapshot (`nightly-2018-05-22`, `lts-11.10`)
    * GHC version (no extra packages)
* Can add extra deps, flag overrides, much more
* Can pull in packages from a Git repo

### stack.yaml example

```yaml
resolver: lts-11.10

# optional
packages:
- .

extra-deps:
- acme-missiles-0.3
```

### Quiz: package.yaml or stack.yaml

Figure out where this information goes

* My code needs to use the `process` package
* I want to specify an exact version of a dependency
* I know that my code will break with `bytestring < 0.10`
* I have two different packages in this project
* I want to build a package with a specific flag

### Stack script interpreter

* Useful for single-file code
* Nicely portable, just needs Stack
* We'll use it a lot in this course

### Stack script example

```haskell
#!/usr/bin/env stack
-- stack --resolver lts-11.10 script
{-# LANGUAGE OverloadedStrings #-}
import qualified Data.ByteString.Lazy.Char8 as BL8
import           Network.HTTP.Simple

main :: IO ()
main = do
    response <- httpLBS "http://httpbin.org/get"

    putStrLn $ "The status code was: " ++
               show (getResponseStatusCode response)
    print $ getResponseHeader "Content-Type" response
    BL8.putStrLn $ getResponseBody response
```

* Automatically detects dependencies from import list
* Installs GHC and packages automatically
* Ignores local config files for reproducibility

### GHCi

* REPL
* Access with `stack ghci` or `stack exec ghci`
* I'm personally GHCi-challenged, we won't use it much (if at all)
  here

## Learning Resources

* <https://www.fpcomplete.com/haskell-syllabus>
    * This course is based on the syllabus
* <https://www.stackage.org/> (and its Hoogle search)
    * We'll be using this a lot!
* <https://haskell-lang.org/libraries>
    * Much of the material is taken from these library docs
* <https://haskell-lang.org/documentation>
    * [Synonyms in base](https://haskell-lang.org/tutorial/synonyms)
    * [Operator glossary](https://haskell-lang.org/tutorial/operators)
* <http://www.yesodweb.com/book>
* <https://www.schoolofhaskell.com>
